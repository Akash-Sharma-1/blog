<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico">

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Basic Data Structure Concepts and Implementations | Akash Sharma’s Blog</title>
<meta name="generator" content="Jekyll v3.9.2" />
<meta property="og:title" content="Basic Data Structure Concepts and Implementations" />
<meta name="author" content="Akash Sharma" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This post is a basic cheat-sheet on some of the basics yet crucial data structures’ underlying concepts and high level implementations. I also try to cover some more interesting related ideas for some of these data structures" />
<meta property="og:description" content="This post is a basic cheat-sheet on some of the basics yet crucial data structures’ underlying concepts and high level implementations. I also try to cover some more interesting related ideas for some of these data structures" />
<link rel="canonical" href="http://localhost:4000/blog/algorithms/stack/queue/linked-list/tree/trie/disjoint%20set/heap/2023/06/29/Basic-Data-Structure-Implementations.html" />
<meta property="og:url" content="http://localhost:4000/blog/algorithms/stack/queue/linked-list/tree/trie/disjoint%20set/heap/2023/06/29/Basic-Data-Structure-Implementations.html" />
<meta property="og:site_name" content="Akash Sharma’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-06-29T00:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Basic Data Structure Concepts and Implementations" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Akash Sharma"},"dateModified":"2023-06-29T00:00:00+05:30","datePublished":"2023-06-29T00:00:00+05:30","description":"This post is a basic cheat-sheet on some of the basics yet crucial data structures’ underlying concepts and high level implementations. I also try to cover some more interesting related ideas for some of these data structures","headline":"Basic Data Structure Concepts and Implementations","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/algorithms/stack/queue/linked-list/tree/trie/disjoint%20set/heap/2023/06/29/Basic-Data-Structure-Implementations.html"},"url":"http://localhost:4000/blog/algorithms/stack/queue/linked-list/tree/trie/disjoint%20set/heap/2023/06/29/Basic-Data-Structure-Implementations.html"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Akash Sharma&apos;s Blog" />
    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W1GFNLSVY2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-W1GFNLSVY2');
</script>

    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Quattrocento+Sans">
    <link rel="stylesheet" href="/blog/assets/css/main.css">
    <link rel="manifest" href="/blog/manifest.json">

    <!-- Support for Bootstrap https://getbootstrap.com -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.15.0/umd/popper.min.js" integrity="sha256-fTuUgtT7O2rqoImwjrhDgbXTKUwyxxujIMRIK7TbuNU=" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

    <!-- Support for pattern background https://github.com/btmills/geopattern -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js" integrity="sha256-AOyAcXCKLfI+FRdiZr4VTj9h9Wwv0YXXa2CPfUWbBS8=" crossorigin="anonymous"></script>

    <!-- Support for SVG icon https://iconify.design -->
    <script src="https://code.iconify.design/1/1.0.0/iconify.min.js"></script>

    <!-- Support for share and reaction btns -->
    <!-- <script type='text/javascript' src='https://platform-api.sharethis.com/js/sharethis.js#property=5fae8b9ee3f5df0012a019ca&product=sop' async='async'></script> -->
    <!-- <script type='text/javascript' src='https://platform-api.sharethis.com/js/sharethis.js#property=650fe938f702ac001998f3a4&product=sop' async='async'></script> -->
    <script src="https://static.elfsight.com/platform/platform.js" data-use-service-core defer></script>

</head>

    <body>
        <header>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <nav class="container navbar navbar-expand-sm py-2">
        <a class="navbar-brand title p-0" href="/blog/">
          <!-- GITHUB ICON -->
          <!-- <span class="iconify" data-icon="octicon:mark-github"></span> -->
          <!-- Personal Icon -->
          <span class="material-icons" style="vertical-align:middle;font-size:inherit">font_download</span>
            <span style="vertical-align:middle">Akash Sharma's Blog</span>
        </a>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <div class="navbar-nav ml-auto">
                
                  
                    <a class="nav-item nav-link text-right" href="/blog/">Home</a>
                  
                  

                
                  
                    <a class="nav-item nav-link text-right" href="/blog/classification/">Classification</a>
                  
                  

                
                  
                    <a class="nav-item nav-link text-right" href="/blog/algorithms/">Algorithms</a>
                  
                  

                
                  
                    <a class="nav-item nav-link text-right" href="/blog/about/">About Me</a>
                  
                  

                
                  
                  
                    <a class="nav-item nav-link text-right" href="https://akash-sharma-1.github.io/">Portfolio</a>
                  

                
            </div>
        </div>
    </nav>
</header>

<script>
    
        $(".navbar").addClass("navbar-light");
        $("a[href$='/blog/algorithms/stack/queue/linked-list/tree/trie/disjoint%20set/heap/2023/06/29/Basic-Data-Structure-Implementations.html']").addClass("active");
    
</script>

        <div class="titlebar text-light">
    <div class="container">
        
            <!-- Post article title -->
            <div class="title pt-3">Basic Data Structure Concepts and Implementations</div>
            <div class="meta pb-3">
                <span class="pr-3">
                    
                        <span class="iconify" data-icon="octicon:calendar"></span>
                        <span>2023/06/29</span>
                    
                </span>

                

                
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Stack">Stack</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Queue">Queue</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Linked-list">Linked-list</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Tree">Tree</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Trie">Trie</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Disjoint Set">Disjoint Set</a>
                        </span>
                    
                
                    
                        <span class="titlebar-info pr-3">
                            <span class="iconify" data-icon="octicon:tag"></span>
                            <a class="text-light" href="/blog/algorithms/categories/#Heap">Heap</a>
                        </span>
                    
                

            </div>
        
    </div>
</div>

<script>
    
        $(".titlebar").geopattern("Basic Data Structure Concepts and Implementations");
    
</script>

<div class="container">
    <div class="row my-2 my-md-4">
        
<div class="content col-md-9">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css" integrity="sha256-HbgiGHMLxHZ3kkAiixyvnaaZFNjNWLYKD/QG6PWaQPc=" crossorigin="anonymous" />

<!-- Support for deep anchor links https://github.com/bryanbraun/anchorjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.js" integrity="sha256-0X7DxIkZMaHhAon0xCc/C/YhG6y0dg8Uj8c50+gbu8c=" crossorigin="anonymous"></script>

<!-- Support for fancybox https://github.com/fancyapps/fancybox -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

<!-- Support for MathJax https://github.com/mathjax/mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous" async></script>

<article class="markdown-body">
    <blockquote>
  <p>This post is a basic cheat-sheet on some of the basics yet crucial data structures’ underlying concepts and high level implementations. I also try to cover some more interesting related ideas for some of these data structures</p>
</blockquote>

<h1 id="stack">Stack</h1>

<h2 id="concept">Concept</h2>

<p>A stack is the basic data structure that can be logically thought of as a linear structure.</p>

<p>Insertion and deletion of items at the top of the stack and the operation should obey the rules LIFO(Last In First Out).</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043117.png" alt="" /></p>

<h2 id="implementation">Implementation</h2>

<p>Each data structure can be implemented by the different method. We can treat stack as a subclass of Array. So we take the array for example here.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nc">Stack</span> <span class="o">{</span>
    <span class="n">constructor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stack</span> <span class="o">=</span> <span class="o">[]</span>
    <span class="o">}</span>
    <span class="n">push</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="n">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
    <span class="o">}</span>
    <span class="n">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">stack</span><span class="o">.</span><span class="na">length</span>
    <span class="o">}</span>
    <span class="n">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">===</span> <span class="mi">0</span>
    <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<h1 id="queues">Queues</h1>

<h2 id="concept-1">Concept</h2>

<p>A queue is a linear data structure. The insertion takes place at one end while the deletion occurs the other one. And the operation should obey the rules FIFO(First In First Out).</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043118.png" alt="" /></p>

<h2 id="implementation-1">Implementation</h2>

<p>Here, we’ll talk two implementations of the queue: Singly-linked Queue and Circular Queue.</p>

<h3 id="singly-linked-queue">Singly-linked Queue</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Queue</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>
  <span class="nx">enQueue</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">deQueue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nx">getHeader</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">getLength</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLength</span><span class="p">()</span> <span class="o">===</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is an O(n) operation to enqueue in a Singly-linked Queue, while it is an average O(1) in a Circular Queue. So here comes the Circular Queue.</p>

<h3 id="circular-queue">Circular Queue</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">SqQueue</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// head of the queue</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// tail of the queue</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">last</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// size of the queue</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">enQueue</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// the array need to expand if last + 1 is the head</span>
    <span class="c1">// `% this.queue.length` is to avoid index out of bounds</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">===</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getLength</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">last</span><span class="p">]</span> <span class="o">=</span> <span class="nx">item</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">last</span> <span class="o">=</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">deQueue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Queue is empty</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span>
    <span class="c1">// if the size of queue is too small </span>
    <span class="c1">// reduce the size half when the real size is quarter of the length and the length is not 2</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLength</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLength</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">resize</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getLength</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">r</span>
  <span class="p">}</span>
  <span class="nx">getHeader</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Queue is empty</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="nx">getLength</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">last</span>
  <span class="p">}</span>
  <span class="nx">resize</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">q</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">[(</span><span class="nx">i</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">first</span><span class="p">)</span> <span class="o">%</span> <span class="k">this</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="nx">q</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">last</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="linked-list">Linked List</h1>

<h2 id="concept-2">Concept</h2>

<p>The linked list is a linear data structure and born to be recursive structure. It can fully use the memory of the computer and manage the memory dynamically and flexibly. But Nodes in the linked list must be read in order from the beginning which can be random in the array, and it uses more memory than the array because of the storage used by their pointers.</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043120.png" alt="" /></p>

<h2 id="implementation-2">Implementation</h2>

<p>Singly-linked list</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">next</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">LinkList</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// size</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// virtual head</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dummyNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">find</span><span class="p">(</span><span class="nx">header</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">currentIndex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">===</span> <span class="nx">currentIndex</span><span class="p">)</span> <span class="k">return</span> <span class="nx">header</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">currentIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">checkIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
    <span class="c1">// the next of the node inserted should be previous node'next</span>
    <span class="c1">// and the previous node's next should point to the node insert,</span>
    <span class="c1">// except inserted to tail which next is null</span>
    <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dummyNode</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
    <span class="k">return</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span>
  <span class="p">}</span>
  <span class="nx">insertNode</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">addToFirst</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">addToLast</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">removeNode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">isLast</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">checkIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
    <span class="nx">index</span> <span class="o">=</span> <span class="nx">isLast</span> <span class="p">?</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">index</span>
    <span class="kd">let</span> <span class="nx">prev</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dummyNode</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">prev</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">--</span>
    <span class="k">return</span> <span class="nx">node</span>
  <span class="p">}</span>
  <span class="nx">removeFirstNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">removeLastNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">removeNode</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">checkIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">index</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Index error</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getNode</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">checkIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="k">return</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">dummyNode</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nx">next</span>
  <span class="p">}</span>
  <span class="nx">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">getSize</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="tree">Tree</h1>

<h2 id="binary-tree">Binary Tree</h2>

<p>Binary Tree is a common one of the many structures of the tree. And it is born to be recursive.</p>

<p>Binary tree start at a root node and each node consists of two child-nodes at most: left node and right node.  The nodes in the bottom are usually called leaf nodes, and when the leaf nodes is full, we call the Full Binary Tree.</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-43121.png" alt="" /></p>

<h2 id="binary-search-tree">Binary Search Tree</h2>

<h2 id="concept-3">Concept</h2>

<p>Binary Search Tree (BST) is one of the binary trees, so it has all the features of the binary tree. But different with the binary tree, the value in any node is larger than the values in all nodes in that node’s left subtree and smaller than the values in all nodes in that node’s right subtree.</p>

<p>This storage method is very suitable for data search. As shown below, when you need to find 6, because the value you need to find is larger than the value of the root node, you only need to find it in the right subtree of the root node, which greatly improves the search efficiency.</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043122.png" alt="" /></p>

<h3 id="implementation-3">Implementation</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">BST</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">getSize</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span>
  <span class="p">}</span>
  <span class="nx">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">===</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// make comparison to the value of the node when insertion</span>
  <span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Above is the basic implementation of BST, the implementation of traversing tree are as follows.</p>

<p>There are three ways for traversing trees: Preorder Traversal, In order Traversal, PostOrder Traversal. The difference of these ways is the time when to visit the root node. In the process of traversing the tree, each node traverses three times, traversing itself, traversing the left subtree and traversing the right subtree. If you need to implement pre-order traversal, you only need to operate the first time when traversing to the node.</p>

<p>Following are the implementation by recursive, if you want to find the non-recursive, <a href="../Algorithm/algorithm-ch.md#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0">click here</a></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Preorder traversal can be used to print the structure of the tree</span>
<span class="c1">// first root then left, and the right is last</span>
<span class="nx">traversal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_pre</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_pre</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_pre</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_pre</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Inorder traversal can be used to order</span>
<span class="c1">// you can sort the value of BST only by one time of Inorder traversal</span>
<span class="c1">// first left , then root and right is last</span>
<span class="nx">midTraversal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_mid</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_mid</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_mid</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_mid</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// Postorder traversal can be used in the case that you want to</span>
<span class="c1">// operate the child node first and then the parent node</span>
<span class="c1">// first left, then right and the root is last</span>
<span class="nx">backTraversal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_back</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_back</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_back</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_back</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>These three ways belong to Deep First Search. Meanwhile, there is Breadth First Search， which traverse the node layer by layer. We can implement it in the queue.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">breadthTraversal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span>
  <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Queue</span><span class="p">()</span>
  <span class="c1">// enqueue the root node</span>
  <span class="nx">q</span><span class="p">.</span><span class="nx">enQueue</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
  <span class="c1">// whether the queue is empty, if true, the traverse is finished.</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">q</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// dequeue the head, and whether it has child-node, </span>
    <span class="c1">// if true, enqueue th left and the right</span>
    <span class="kd">let</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">deQueue</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="nx">q</span><span class="p">.</span><span class="nx">enQueue</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="nx">q</span><span class="p">.</span><span class="nx">enQueue</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We will introduce how to find the smallest and the biggest in the tree. Because of the feature of the BST, the smallest must be on the left while the biggest is on the right.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getMin</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getMin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">).</span><span class="nx">value</span>
<span class="p">}</span>
<span class="nx">_getMin</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getMin</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">getMax</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getMax</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">).</span><span class="nx">value</span>
<span class="p">}</span>
<span class="nx">_getMax</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getMin</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Round up and Round down</strong> Since these two operations are opposite, the code is similar, here we’ll talk about round down. According to the feature of the BST, the target must be on the left. We only need to traverse the left nodes until the current node is no bigger than the target. And then adjudge if there have right nodes, if do, continue the judgment recursively.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">floor</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_floor</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">node</span> <span class="p">?</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
<span class="nx">_floor</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="nx">v</span><span class="p">)</span> <span class="k">return</span> <span class="nx">v</span>
  <span class="c1">// if the current node is bigger than the target, continue</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_floor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// whether the current node has the right subtree</span>
  <span class="kd">let</span> <span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_floor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="k">return</span> <span class="nx">right</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Rank</strong> get the rank of the given value or get the value of the given rank, and these two operations are also similar. We as usual only introduce the operation of the latter. We should retrofit the code to add a property <code class="language-plaintext highlighter-rouge">size</code> to each node which indicates how many subnodes a node has, include itself.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="c1">// add code </span>
    <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// add code</span>
<span class="nx">_getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">node</span> <span class="p">?</span> <span class="nx">node</span><span class="p">.</span><span class="nx">size</span> <span class="p">:</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// edit code</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// edit code</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">size</span><span class="o">++</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
<span class="nx">select</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_select</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">node</span> <span class="p">?</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
<span class="nx">_select</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span>
  <span class="c1">// get the size of the node in the left subtree</span>
  <span class="kd">let</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="p">?</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">.</span><span class="nx">size</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="c1">// if size is bigger than k, the target is in the left side</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_select</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
  <span class="c1">// if the size is smaller than k, the target is in the right side</span>
  <span class="c1">// there is need to recalculate the k</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">size</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">)</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_select</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here come the most difficult parts in BST: delete nodes, include the following cases:</p>

<ul>
  <li>the target node has no subtree</li>
  <li>the target node has only one subtree</li>
  <li>the target node has two subtrees</li>
</ul>

<p>The first and the second is easy to resolve, while the last is a little difficult. 
So let us implement the simple operation at first: delete the minimum node. It could not appear in the third case, and the operation delete the largest node is opposite, so there is no need to talk.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">delectMin</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delectMin</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_delectMin</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// rescursive  the left subtree</span>
  <span class="c1">// if the left subtree is null, check if the right is exist</span>
  <span class="c1">// if true, take the right subtree in place of the delect node</span>
  <span class="k">if</span> <span class="p">((</span><span class="nx">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delectMin</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
  <span class="c1">// update the size at last</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The last, how to delete a random node. T.Hibbard put forward the solution in 1962 which can be used to solve the third case.</p>

<p>In this situation, we should get the descendant node of the current node which is the smallest node in the current node’s right subtree and replace the target node by it. And then assign the descendant node with the subtree of the target, and give the right subtree without decent node to the left subtree.</p>

<p>Since the root node is bigger than all the nodes in left subtree, while less than all the nodes in the right subtree. When you want to delete a root node, you need to pick a suitable node to take place, which should bigger than the root node that means it must come from the right subtree. Then the smallest node would be picked with the limit that all the nodes in the right subtree should bigger than the root node.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">delect</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delect</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">_delect</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span>
  <span class="c1">// if the target is less than the current node, serach in the left subtree</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delect</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if the target is bigger than the current node, serach in the right subtree</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delect</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// in this case, the target has been found</span>
    <span class="c1">// check if the node has subtree</span>
    <span class="c1">// if true, return the subtree, same operation with `_delectMin`</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span>
    <span class="c1">// in this case, the node has both subtree</span>
    <span class="c1">// get the decendent node of the current node, </span>
    <span class="c1">// which is the smallest node in the right subtree</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getMin</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="c1">// delete the smallest after got it</span>
    <span class="c1">// Then assign the subtree after deleting the node to the smallest node</span>
    <span class="nx">min</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_delectMin</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
    <span class="c1">// subtree is the same</span>
    <span class="nx">min</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span>
    <span class="nx">node</span> <span class="o">=</span> <span class="nx">min</span>
  <span class="p">}</span>
  <span class="c1">// update size</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getSize</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="avl-tree">AVL Tree</h2>

<h3 id="concept-4">Concept</h3>

<p>BST is limited in the production because it is not the strict O(log N) and sometimes it will degenerate to a linked list, e.g., insertion of an ascending order number list.</p>

<p>AVL tree improved the BST, the difference between the left subtree height and the right subtree height in each node is less than 1, which can ensure that the time complexity is strict O(log N). Based on this, the insertion and deletion may need to rotate the tree to balance the height.</p>

<h3 id="implementation-4">Implementation</h3>

<p>Since improved from the BST, some codes in AVL are repeated, which we will not analysis again.</p>

<p>Four cases are in the node insertion of AVL tree.</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043123.png" alt="" /></p>

<p>As for l-l(left-left), the new node T1 is in the left side of the node X. The tree cannot keep balance by now, so there need to rotate. After rotating, the tree should still obey the rules the mid is bigger than the left and less than the right according to the features of the BST.</p>

<p>before rotating: T1 &lt; X &lt; T2 &lt; Y &lt; T3 &lt; Z &lt; T4， after rotating, the node Y is the root, so we need to add the right subtree of Y to the left of the Z and update the height of the nodes.</p>

<p>The same situation to the r-r, opposite to the l-l, we do not talk more.</p>

<p>As for the l-r, the new node is on the right side of the node X, and we need to rotate twice.</p>

<p>First, rotate the left node to the left, after that the case change to l-l, we can handle it like l-l.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="kc">null</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">AVL</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="p">}</span>
  <span class="nx">addNode</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_addChild</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span>
    <span class="kd">let</span> <span class="nx">factor</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="c1">// when need right-rotate, the height of the left subtree must higher than right </span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">factor</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_rightRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// when need left-rotate, the height of the left subtree must lower than right</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">factor</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_leftRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// l-r</span>
    <span class="c1">// left subtree is higher than right, </span>
    <span class="c1">// and the right subtree of the left subtree of the node </span>
    <span class="c1">// is higher than the left subtree of the left subtree of the node</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">factor</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_leftRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_rightRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// r-l</span>
    <span class="c1">// left subtree is lower than right, </span>
    <span class="c1">// and the right subtree of the right subtree of the node </span>
    <span class="c1">// is lower than the left subtree of the right subtree of the node</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">factor</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_rightRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_leftRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">node</span>
  <span class="p">}</span>
  <span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">height</span>
  <span class="p">}</span>
  <span class="nx">_getBalanceFactor</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">)</span> <span class="o">-</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// right-rotate</span>
  <span class="c1">//           5                    2</span>
  <span class="c1">//         /   \                /   \</span>
  <span class="c1">//        2     6   ==&gt;       1      5</span>
  <span class="c1">//       /  \               /       /  \</span>
  <span class="c1">//      1    3             new     3    6</span>
  <span class="c1">//     /</span>
  <span class="c1">//    new</span>
  <span class="nx">_rightRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// new root after rotate</span>
    <span class="kd">let</span> <span class="nx">newRoot</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span>
    <span class="c1">// node need to be moved</span>
    <span class="kd">let</span> <span class="nx">moveNode</span> <span class="o">=</span> <span class="nx">newRoot</span><span class="p">.</span><span class="nx">right</span>
    <span class="c1">// right node of the node 2 change to node 5</span>
    <span class="nx">newRoot</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">node</span>
    <span class="c1">// left node of node 5 change to node 3</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">moveNode</span>
    <span class="c1">// update the height</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span>
    <span class="nx">newRoot</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span>
      <span class="mi">1</span> <span class="o">+</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">newRoot</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">newRoot</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span>

    <span class="k">return</span> <span class="nx">newRoot</span>
  <span class="p">}</span>
  <span class="c1">// left-rotate</span>
  <span class="c1">//           4                    6</span>
  <span class="c1">//         /   \                /   \</span>
  <span class="c1">//        2     6   ==&gt;       4      7</span>
  <span class="c1">//             /  \         /   \      \</span>
  <span class="c1">//            5     7      2     5      new</span>
  <span class="c1">//                   \</span>
  <span class="c1">//                    new</span>
  <span class="nx">_leftRotate</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// new root after rotate</span>
    <span class="kd">let</span> <span class="nx">newRoot</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span>
    <span class="c1">// node need to be moved</span>
    <span class="kd">let</span> <span class="nx">moveNode</span> <span class="o">=</span> <span class="nx">newRoot</span><span class="p">.</span><span class="nx">left</span>
    <span class="c1">// left node of the node 6 change to node 4</span>
    <span class="nx">newRoot</span><span class="p">.</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">node</span>
    <span class="c1">// right node of the node 4 change to node 5</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">moveNode</span>
    <span class="c1">// update the height</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span>
    <span class="nx">newRoot</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span>
      <span class="mi">1</span> <span class="o">+</span>
      <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">newRoot</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="k">this</span><span class="p">.</span><span class="nx">_getHeight</span><span class="p">(</span><span class="nx">newRoot</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span>

    <span class="k">return</span> <span class="nx">newRoot</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="trie">Trie</h1>

<h2 id="concept-5">Concept</h2>

<p>In computer science, a trie, also called digital tree and sometimes radix tree or prefix tree (as prefixes can search them), is a kind of search tree—an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings.</p>

<p>Simply, this data structure is used to search string easily, with the following features:</p>

<ul>
  <li>the root is on behalf of the empty string, and each node has N links (N is 26 in searching English character), each link represents a character.</li>
  <li>all nodes do not store a character, and only the path store, this is different from other tree structures.</li>
  <li>the character in the path from the root to the random node can combine to the strings corresponding to the node</li>
</ul>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043124.png" alt="" /></p>

<h2 id="implementation-5">Implementation</h2>

<p>Generally, the implementation of the trie is much more simple than others, let’s take the English character searching for example.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">TrieNode</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// the times of each character travels through the node</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// the amount of the string to the node</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">end</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">// links</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">26</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">Trie</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// root node, empty string</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TrieNode</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// insert string</span>
  <span class="nx">insert</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">str</span><span class="p">)</span> <span class="k">return</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// get the index of the character</span>
      <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">()</span>
      <span class="c1">// create if without the index</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TrieNode</span><span class="p">()</span>
      <span class="p">}</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">path</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">end</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="c1">// The number of times the search string appears</span>
  <span class="nx">search</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">str</span><span class="p">)</span> <span class="k">return</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">()</span>
      <span class="c1">// if the index does node exists, there is no string to be search</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
      <span class="p">}</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">end</span>
  <span class="p">}</span>
  <span class="c1">// delete the string</span>
  <span class="k">delete</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span> <span class="k">return</span>
    <span class="kd">let</span> <span class="nx">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">charCodeAt</span><span class="p">()</span> <span class="o">-</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">()</span>
      <span class="c1">// if the path is 0,  this means no string pass </span>
      <span class="c1">// delete it</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">path</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">next</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="nx">node</span><span class="p">.</span><span class="nx">end</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="disjoint-set">Disjoint Set</h1>

<h2 id="concept-6">Concept</h2>

<p>Disjoint Set is a special data structure of the tree. Each node in this structure has a parent node, if there is only the current node, then the pointer of the parent node points to itself.</p>

<p>Two important operations are in this structure,</p>

<ul>
  <li>Find: find the member of the set to which the element belongs,  and it can be used to determine whether the two elements belong to the same set</li>
  <li>Union: combine two sets to a new set</li>
</ul>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043126.png" alt="" /></p>

<h2 id="implementation-6">Implementation</h2>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DisjointSet</span> <span class="p">{</span>
  <span class="c1">// init sample</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// each node's parenet node is iteself when initialization</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
    <span class="c1">// record the deepth of the tree to optimize the complexity of query</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">find</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// check whether the parent node of the current node is itself, if false, means has not found yet</span>
    <span class="c1">// uglify the path for optimization</span>
    <span class="c1">// assume the parent node of the current node is A</span>
    <span class="c1">// mount the current node to the parent node of A to deeply optimize</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">p</span> <span class="o">!=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">p</span><span class="p">]]</span>
      <span class="nx">p</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">p</span>
  <span class="p">}</span>
  <span class="nx">isConnected</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// combine</span>
  <span class="nx">union</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// find the parent node of the two number</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">j</span><span class="p">)</span> <span class="k">return</span>
    <span class="c1">// compare the deepth of the two trees </span>
    <span class="c1">// if the deepth is equal, add as you wish</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">parent</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">rank</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="heap">Heap</h1>

<h2 id="concept-7">Concept</h2>

<p>Heap is usually treated as a tree-based array list.</p>

<p>It is implemented by constructure binary heap, one of the BST. Features are as follows:</p>

<ul>
  <li>each node either larger or less than all its child-nodes</li>
  <li>heap is always a full-tree</li>
</ul>

<p>We call the heap <strong>Max Binary Heap</strong> that its root value is the largest, while the heap with the smallest root value is called  <strong>Min Binary Heap</strong>.</p>

<p>Priority Queue also can be implemented by the heap, with the same operation.</p>

<h2 id="implementation-7">Implementation</h2>

<p>For the implementation, we’ll take an example of a <strong>Max Binary Heap</strong>.
The index of the left-child of each node is <code class="language-plaintext highlighter-rouge">i * 2 + 1</code>, while the right’s is <code class="language-plaintext highlighter-rouge">i * 2 + 2</code>, and the parent’s is <code class="language-plaintext highlighter-rouge">(i - 1) / 2</code></p>

<p>There are two central operations in the heap, <code class="language-plaintext highlighter-rouge">shiftUp</code> and <code class="language-plaintext highlighter-rouge">shiftDown</code>. The former is used for insertion, and the latter is to delete the root node.</p>

<p>The key of <code class="language-plaintext highlighter-rouge">shiftUp</code> is to compare with the parent node bubbly and exchange the position if it is larger than the parent.</p>

<p>As for <code class="language-plaintext highlighter-rouge">shiftDown</code>, first exchange root and the tail node, and then delete the tail. After that, Compare with the parent node and both child-nodes circularly, if the child-node is larger, assign the parent node with the larger node.</p>

<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-43127.png" alt="" /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MaxHeap</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>
  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">removeMax</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">parseInt</span><span class="p">((</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">k</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">_shiftUp</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// exchange if the current node is bigger than the parent node</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span>
      <span class="c1">// update the index to the parent node's</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">_shiftDown</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// exchange the head and tail, then delete the tail</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// check whether the node has left child-node, </span>
    <span class="c1">// the right must exist because of full-tree</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
      <span class="c1">// check whether the right child exits, and whether it is largger than the left</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="nx">j</span><span class="o">++</span>
      <span class="c1">// check whether the parenet node is largger than both child-nodes</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="k">break</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="nx">j</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">_swap</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">rightValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rightValue</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MaxHeap</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="p">}</span>
  <span class="nx">size</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">}</span>
  <span class="nx">empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_shiftUp</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">removeMax</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_shiftDown</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">parseInt</span><span class="p">((</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">k</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="nx">_shiftUp</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// exchange if the current node is bigger than the parent node</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)])</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">))</span>
      <span class="c1">// update the index to the parent node's</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getParentIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">_shiftDown</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// exchange the head and delete the tail</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// check if the node has left child-node, the right must exist if true according to the binary heap</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLeftIndex</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
      <span class="c1">// check if the right child exits, and whether it is largger than the left</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="nx">j</span><span class="o">++</span>
      <span class="c1">// check if the parenet node is largger than both child-nodes</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="k">break</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">_swap</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">k</span> <span class="o">=</span> <span class="nx">j</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">_swap</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">rightValue</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">heap</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">=</span> <span class="nx">rightValue</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="alert alert-info" role="alert">
  I would be covering some more basic Data-structures' concept and implementation in this post.Also, would be covering some advanced data-structures as well as their applications in some other post.
</div>

</article>

<br>
<center><p>Thank you for reading this article 😊</p></center>
<center><p>I'd love to hear your thoughts & feedback in the comment section below!</p></center>

<div align="center" class="mt-2">
    <svg width="131" height="42" viewBox="0 0 131 42" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M0.5 0.5H116C124.008 0.5 130.5 6.99187 130.5 15V41.5H15C6.99187 41.5 0.5 35.0081 0.5 27V0.5Z" fill="black" stroke="#ACACAC"/>
        <path d="M17.9605 24.1575C21.4266 26.9643 26.3836 26.9643 29.8497 24.1575L28.5095 22.5026C25.8248 24.6766 21.9854 24.6766 19.3007 22.5026L17.9605 24.1575Z" fill="white"/>
        <path d="M19.404 20.5134V17.6365H21.5336V20.5134H19.404Z" fill="white"/>
        <path d="M26.012 17.6365V20.5134H28.1415V17.6365H26.012Z" fill="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M35 21.5C35 27.8513 29.8513 33 23.5 33C17.1487 33 12 27.8513 12 21.5C12 15.1487 17.1487 10 23.5 10C29.8513 10 35 15.1487 35 21.5ZM32.8705 21.5C32.8705 26.6752 28.6752 30.8705 23.5 30.8705C18.3248 30.8705 14.1295 26.6752 14.1295 21.5C14.1295 16.3248 18.3248 12.1295 23.5 12.1295C28.6752 12.1295 32.8705 16.3248 32.8705 21.5Z" fill="white"/>
        <path d="M48.2896 22.1781C49.2796 22.1781 50.088 22.4414 50.7148 22.9681C51.3474 23.4889 51.6638 24.356 51.6638 25.5692V32.0851H49.098V26.1995C49.098 25.6905 49.0307 25.2999 48.8959 25.0277C48.6499 24.5305 48.1813 24.282 47.49 24.282C46.6407 24.282 46.0578 24.646 45.7415 25.3739C45.5775 25.7586 45.4954 26.2498 45.4954 26.8475V32.0851H43V22.4266H45.4164V23.8381C45.7385 23.341 46.0432 22.9829 46.3302 22.764C46.8457 22.3734 47.4988 22.1781 48.2896 22.1781Z" fill="white"/>
        <path d="M57.5604 30.3008C58.2926 30.3008 58.855 30.0374 59.2475 29.5107C59.6399 28.984 59.8362 28.2353 59.8362 27.2648C59.8362 26.2942 59.6399 25.5485 59.2475 25.0277C58.855 24.501 58.2926 24.2376 57.5604 24.2376C56.8282 24.2376 56.2629 24.501 55.8646 25.0277C55.4721 25.5485 55.2758 26.2942 55.2758 27.2648C55.2758 28.2353 55.4721 28.984 55.8646 29.5107C56.2629 30.0374 56.8282 30.3008 57.5604 30.3008ZM62.4634 27.2648C62.4634 28.6851 62.0592 29.9013 61.2508 30.9133C60.4425 31.9194 59.2152 32.4225 57.5692 32.4225C55.9231 32.4225 54.6959 31.9194 53.8875 30.9133C53.0791 29.9013 52.6749 28.6851 52.6749 27.2648C52.6749 25.8681 53.0791 24.6578 53.8875 23.6339C54.6959 22.6101 55.9231 22.0982 57.5692 22.0982C59.2152 22.0982 60.4425 22.6101 61.2508 23.6339C62.0592 24.6578 62.4634 25.8681 62.4634 27.2648Z" fill="white"/>
        <path d="M62.5608 24.2997V22.4977H63.8964V19.799H66.3742V22.4977H67.9295V24.2997H66.3742V29.4131C66.3742 29.8096 66.424 30.0581 66.5236 30.1587C66.6232 30.2534 66.9278 30.3008 67.4374 30.3008C67.5136 30.3008 67.5927 30.3008 67.6747 30.3008C67.7626 30.2949 67.8475 30.2889 67.9295 30.283V32.1739L66.7433 32.2183C65.56 32.2597 64.7516 32.0526 64.3181 31.5969C64.037 31.3069 63.8964 30.8601 63.8964 30.2564V24.2997H62.5608Z" fill="white"/>
        <path d="M77.602 22.1958C78.8615 22.1958 79.8456 22.6545 80.5544 23.5718C81.2691 24.4891 81.6264 25.6728 81.6264 27.1227C81.6264 28.6259 81.2749 29.8717 80.572 30.8601C79.869 31.8484 78.8878 32.3426 77.6284 32.3426C76.8376 32.3426 76.202 32.1828 75.7217 31.8632C75.4346 31.6738 75.1242 31.3424 74.7903 30.8689V32.0851H72.3388V19.0178H74.8342V23.6695C75.1505 23.2197 75.4991 22.8764 75.8798 22.6397C76.3309 22.3438 76.905 22.1958 77.602 22.1958ZM76.9606 30.2564C77.605 30.2564 78.1058 29.993 78.4631 29.4663C78.8205 28.9396 78.9991 28.2472 78.9991 27.389C78.9991 26.7025 78.9113 26.1344 78.7355 25.6846C78.4016 24.8324 77.7866 24.4063 76.8903 24.4063C75.9823 24.4063 75.3585 24.8235 75.0187 25.658C74.843 26.1018 74.7551 26.6759 74.7551 27.3802C74.7551 28.2087 74.9367 28.8952 75.2999 29.4397C75.6631 29.9842 76.2167 30.2564 76.9606 30.2564Z" fill="white"/>
        <path d="M83.0945 33.9405L83.4108 33.9582C83.6568 33.9701 83.8911 33.9612 84.1137 33.9316C84.3363 33.902 84.5238 33.8339 84.6761 33.7274C84.8225 33.6268 84.9573 33.4167 85.0803 33.0971C85.2092 32.7775 85.2619 32.5822 85.2385 32.5112L81.7237 22.4089H84.5092L86.6004 29.5462L88.5774 22.4089H91.2398L87.9536 31.9253C87.3209 33.76 86.8201 34.8963 86.451 35.3342C86.082 35.7781 85.3439 36 84.2368 36C84.0142 36 83.8355 35.997 83.7008 35.9911C83.566 35.9911 83.3639 35.9822 83.0945 35.9645V33.9405Z" fill="white"/>
        <path d="M97.783 27.1405H101.069L99.4525 21.9916L97.783 27.1405ZM97.95 19H101.008L105.594 32.0851H102.66L101.825 29.3953H97.0537L96.1575 32.0851H93.3281L97.95 19Z" fill="white"/>
        <path d="M110.59 32.0851H107.902V19H110.59V32.0851Z" fill="white"/>
        <path d="M106.306 19H112V21.2258H106.306V19Z" fill="white"/>
        <path d="M106.306 29.8624H112V32.0882H106.306V29.8624Z" fill="white"/>
        <path d="M42.9754 9.89597L43.9953 13.8667L45.0301 9.89597H46.0303L47.07 13.8432L48.1544 9.89597H49.0456L47.5058 14.9347H46.5799L45.5005 11.0345L44.4558 14.9347H43.5299L42 9.89597H42.9754Z" fill="white"/>
        <path d="M49.8156 9.89597H50.6622V10.7663C50.7316 10.597 50.9016 10.3915 51.1722 10.15C51.4429 9.90538 51.7548 9.78306 52.108 9.78306C52.1245 9.78306 52.1526 9.78463 52.1922 9.78777C52.2318 9.7909 52.2994 9.79718 52.3952 9.80659V10.7005C52.3424 10.6911 52.2928 10.6848 52.2466 10.6817C52.2037 10.6785 52.1559 10.6769 52.1031 10.6769C51.6541 10.6769 51.3092 10.815 51.0682 11.091C50.8273 11.3638 50.7068 11.679 50.7068 12.0366V14.9347H49.8156V9.89597Z" fill="white"/>
        <path d="M53.0662 9.9195H53.9722V14.9347H53.0662V9.9195ZM53.0662 8.02352H53.9722V8.98327H53.0662V8.02352Z" fill="white"/>
        <path d="M55.4008 8.48928H56.3019V9.89597H57.1485V10.5876H56.3019V13.8761C56.3019 14.0518 56.3646 14.1694 56.49 14.229C56.5593 14.2635 56.6749 14.2807 56.8366 14.2807C56.8795 14.2807 56.9257 14.2807 56.9752 14.2807C57.0248 14.2776 57.0825 14.2729 57.1485 14.2666V14.9347C57.0462 14.9629 56.9389 14.9833 56.8267 14.9958C56.7178 15.0084 56.599 15.0146 56.4702 15.0146C56.0543 15.0146 55.7721 14.9143 55.6236 14.7135C55.475 14.5097 55.4008 14.2462 55.4008 13.9232V10.5876H54.6828V9.89597H55.4008V8.48928Z" fill="white"/>
        <path d="M58.1215 8.48928H59.0227V9.89597H59.8693V10.5876H59.0227V13.8761C59.0227 14.0518 59.0854 14.1694 59.2108 14.229C59.2801 14.2635 59.3957 14.2807 59.5574 14.2807C59.6003 14.2807 59.6465 14.2807 59.696 14.2807C59.7455 14.2776 59.8033 14.2729 59.8693 14.2666V14.9347C59.767 14.9629 59.6597 14.9833 59.5475 14.9958C59.4386 15.0084 59.3197 15.0146 59.191 15.0146C58.7751 15.0146 58.4929 14.9143 58.3444 14.7135C58.1958 14.5097 58.1215 14.2462 58.1215 13.9232V10.5876H57.4036V9.89597H58.1215V8.48928Z" fill="white"/>
        <path d="M62.8723 9.78306C63.2486 9.78306 63.6134 9.86775 63.9666 10.0371C64.3197 10.2033 64.5888 10.4198 64.7736 10.6864C64.9518 10.9404 65.0707 11.2368 65.1301 11.5755C65.1829 11.8076 65.2093 12.1777 65.2093 12.6858H61.3226C61.3391 13.1971 61.4662 13.6079 61.7039 13.9185C61.9415 14.2258 62.3095 14.3795 62.808 14.3795C63.2734 14.3795 63.6447 14.2337 63.922 13.942C64.0804 13.7726 64.1927 13.5766 64.2587 13.3539H65.135C65.1119 13.5389 65.0344 13.7459 64.9023 13.9749C64.7736 14.2007 64.6284 14.3858 64.4666 14.5301C64.196 14.781 63.8609 14.9503 63.4615 15.0382C63.247 15.0883 63.0044 15.1134 62.7337 15.1134C62.0735 15.1134 61.5141 14.886 61.0552 14.4313C60.5964 13.9733 60.367 13.3335 60.367 12.5118C60.367 11.7026 60.5981 11.0455 61.0602 10.5405C61.5223 10.0355 62.1264 9.78306 62.8723 9.78306ZM64.2933 12.0131C64.257 11.6461 64.1729 11.3528 64.0408 11.1333C63.7966 10.7256 63.3889 10.5217 62.8179 10.5217C62.4086 10.5217 62.0653 10.6628 61.788 10.9451C61.5108 11.2243 61.3639 11.5802 61.3474 12.0131H64.2933Z" fill="white"/>
        <path d="M66.2071 9.89597H67.0537V10.6111C67.3046 10.3163 67.5703 10.1045 67.8509 9.97595C68.1315 9.84736 68.4434 9.78306 68.7867 9.78306C69.5392 9.78306 70.0476 10.0324 70.3116 10.5311C70.4569 10.804 70.5295 11.1945 70.5295 11.7026V14.9347H69.6234V11.759C69.6234 11.4516 69.5756 11.2039 69.4798 11.0157C69.3214 10.702 69.0342 10.5452 68.6183 10.5452C68.4071 10.5452 68.2338 10.5656 68.0984 10.6064C67.8542 10.6754 67.6396 10.8134 67.4548 11.0204C67.3062 11.1866 67.2089 11.3591 67.1627 11.5379C67.1198 11.7135 67.0983 11.966 67.0983 12.2953V14.9347H66.2071V9.89597Z" fill="white"/>
        <path d="M74.4015 8H75.268V10.5076C75.4628 10.2661 75.6955 10.0826 75.9661 9.95714C76.2368 9.82854 76.5306 9.76424 76.8474 9.76424C77.5076 9.76424 78.0423 9.98066 78.4516 10.4135C78.8642 10.8432 79.0705 11.4783 79.0705 12.3189C79.0705 13.1155 78.8675 13.7773 78.4615 14.3042C78.0555 14.8312 77.4927 15.0946 76.7732 15.0946C76.3705 15.0946 76.0305 15.0021 75.7532 14.817C75.5882 14.7073 75.4116 14.5316 75.2234 14.2901V14.9347H74.4015V8ZM76.7187 14.3466C77.2006 14.3466 77.5604 14.1647 77.7981 13.8008C78.039 13.437 78.1595 12.9571 78.1595 12.3612C78.1595 11.8312 78.039 11.3921 77.7981 11.0439C77.5604 10.6958 77.2089 10.5217 76.7435 10.5217C76.3375 10.5217 75.981 10.6644 75.674 10.9498C75.3703 11.2352 75.2185 11.7057 75.2185 12.3612C75.2185 12.8348 75.2812 13.219 75.4066 13.5139C75.641 14.069 76.0784 14.3466 76.7187 14.3466Z" fill="white"/>
        <path d="M83.3262 9.89597H84.3115C84.1861 10.219 83.9071 10.9561 83.4747 12.1072C83.1513 12.9728 82.8806 13.6785 82.6627 14.2243C82.1478 15.5102 81.7847 16.2943 81.5735 16.5766C81.3622 16.8589 80.9991 17 80.4842 17C80.3588 17 80.2614 16.9953 80.1921 16.9859C80.1261 16.9765 80.0435 16.9592 79.9445 16.9341V16.1626C80.0997 16.2033 80.2119 16.2284 80.2812 16.2378C80.3505 16.2473 80.4116 16.252 80.4644 16.252C80.6294 16.252 80.7499 16.2253 80.8258 16.172C80.9051 16.1218 80.9711 16.0591 81.0239 15.9838C81.0404 15.9587 81.0998 15.8301 81.2021 15.598C81.3045 15.3659 81.3787 15.1934 81.4249 15.0805L79.4643 9.89597H80.4743L81.8953 13.9984L83.3262 9.89597Z" fill="white"/>
        <path d="M87.7033 8H88.5945V10.5781C88.8057 10.3241 88.9955 10.1453 89.1639 10.0418C89.4511 9.86304 89.8092 9.77365 90.2383 9.77365C91.0074 9.77365 91.5289 10.0293 91.8029 10.5405C91.9514 10.8197 92.0257 11.207 92.0257 11.7026V14.9347H91.1097V11.759C91.1097 11.3889 91.0602 11.1176 90.9612 10.9451C90.7994 10.6691 90.4958 10.5311 90.0502 10.5311C89.6805 10.5311 89.3454 10.6519 89.0451 10.8934C88.7447 11.1349 88.5945 11.5912 88.5945 12.2624V14.9347H87.7033V8Z" fill="white"/>
        <path d="M94.1375 9.89597V13.241C94.1375 13.4982 94.1804 13.7083 94.2662 13.8714C94.4246 14.1725 94.7201 14.3231 95.1525 14.3231C95.773 14.3231 96.1955 14.0596 96.42 13.5327C96.5421 13.2504 96.6032 12.863 96.6032 12.3706V9.89597H97.4944V14.9347H96.6527L96.6626 14.1913C96.5471 14.3826 96.4035 14.5442 96.2318 14.6759C95.8919 14.9394 95.4793 15.0711 94.994 15.0711C94.2381 15.0711 93.7232 14.8312 93.4493 14.3513C93.3007 14.0941 93.2265 13.7507 93.2265 13.321V9.89597H94.1375Z" fill="white"/>
        <path d="M98.7892 9.89597H99.6706V10.6111C99.8818 10.3633 100.073 10.183 100.245 10.07C100.539 9.87872 100.872 9.78306 101.245 9.78306C101.668 9.78306 102.008 9.88186 102.265 10.0795C102.41 10.1924 102.542 10.3586 102.661 10.5781C102.859 10.3084 103.092 10.1093 103.359 9.98066C103.627 9.84893 103.927 9.78306 104.26 9.78306C104.973 9.78306 105.459 10.0277 105.716 10.517C105.855 10.7804 105.924 11.1349 105.924 11.5802V14.9347H104.998V11.4344C104.998 11.0988 104.909 10.8683 104.731 10.7428C104.556 10.6174 104.341 10.5546 104.087 10.5546C103.737 10.5546 103.435 10.666 103.181 10.8887C102.93 11.1113 102.805 11.483 102.805 12.0037V14.9347H101.899V11.6461C101.899 11.3042 101.856 11.0549 101.77 10.8981C101.635 10.6628 101.382 10.5452 101.012 10.5452C100.676 10.5452 100.369 10.6691 100.091 10.9169C99.8174 11.1647 99.6805 11.6132 99.6805 12.2624V14.9347H98.7892V9.89597Z" fill="white"/>
        <path d="M107.818 13.5938C107.818 13.8385 107.912 14.0314 108.1 14.1725C108.288 14.3136 108.511 14.3842 108.769 14.3842C109.082 14.3842 109.386 14.3152 109.68 14.1772C110.175 13.9482 110.422 13.5734 110.422 13.0528V12.3706C110.313 12.4365 110.173 12.4914 110.001 12.5353C109.83 12.5792 109.661 12.6106 109.496 12.6294L108.957 12.6952C108.633 12.736 108.391 12.8003 108.229 12.8881C107.955 13.0355 107.818 13.2708 107.818 13.5938ZM109.977 11.8813C110.181 11.8562 110.318 11.7747 110.388 11.6367C110.427 11.5614 110.447 11.4532 110.447 11.3121C110.447 11.0235 110.338 10.815 110.12 10.6864C109.906 10.5546 109.597 10.4888 109.194 10.4888C108.729 10.4888 108.399 10.6079 108.204 10.8463C108.095 10.978 108.024 11.1741 107.991 11.4344H107.159C107.176 10.8134 107.387 10.3821 107.793 10.1406C108.202 9.89598 108.676 9.77365 109.214 9.77365C109.838 9.77365 110.345 9.88657 110.734 10.1124C111.12 10.3382 111.313 10.6895 111.313 11.1662V14.069C111.313 14.1568 111.332 14.2274 111.368 14.2807C111.408 14.334 111.488 14.3607 111.611 14.3607C111.65 14.3607 111.695 14.3591 111.744 14.356C111.794 14.3497 111.847 14.3419 111.903 14.3325V14.9582C111.764 14.9958 111.658 15.0193 111.586 15.0288C111.513 15.0382 111.414 15.0429 111.289 15.0429C110.982 15.0429 110.759 14.9394 110.62 14.7324C110.548 14.6226 110.496 14.4673 110.467 14.2666C110.285 14.4924 110.024 14.6884 109.684 14.8547C109.345 15.0209 108.97 15.104 108.561 15.104C108.069 15.104 107.666 14.9629 107.352 14.6806C107.042 14.3952 106.887 14.0392 106.887 13.6127C106.887 13.1453 107.041 12.7831 107.348 12.5259C107.654 12.2687 108.057 12.1103 108.556 12.0507L109.977 11.8813Z" fill="white"/>
        <path d="M112.678 9.89597H113.524V10.6111C113.775 10.3163 114.041 10.1045 114.321 9.97595C114.602 9.84736 114.914 9.78306 115.257 9.78306C116.01 9.78306 116.518 10.0324 116.782 10.5311C116.927 10.804 117 11.1945 117 11.7026V14.9347H116.094V11.759C116.094 11.4516 116.046 11.2039 115.95 11.0157C115.792 10.702 115.505 10.5452 115.089 10.5452C114.878 10.5452 114.704 10.5656 114.569 10.6064C114.325 10.6754 114.11 10.8134 113.925 11.0204C113.777 11.1866 113.679 11.3591 113.633 11.5379C113.59 11.7135 113.569 11.966 113.569 12.2953V14.9347H112.678V9.89597Z" fill="white"/>
    </svg>
</div>

<!-- <div class="sharethis-inline-reaction-buttons"></div>
<style>
  #st-1 .st-btn > svg
  {
    width:28px;
  }
</style> -->
<hr></hr>
<center><p>If you liked it, please share it with your friends and help this blog to grow!</p></center>
<div class="elfsight-app-c37f9300-422e-4d9d-a637-20a2cd5ddb06"></div>



    

<!-- <div class="sharethis-inline-share-buttons"></div> -->
<!-- <center><div class="addthis_inline_share_toolbox"></div></center> -->
<br>
<br>


    
        <script src="https://utteranc.es/client.js"
                repo="Akash-Sharma-1/Utteranc-Comments-Repo-Blog"
                issue-term="pathname"
                theme="github-light"
                crossorigin="anonymous"
                async>
        </script>
    


<script>
    // Add anchors to headers.
    anchors.add();

    // Show images in fancybox.
    $("p img").each(function() {
        $(this).wrapAll('<a data-fancybox="images" data-caption="' + this.alt + '" href="' + this.src + '"></a>');
    });
    $('[data-fancybox="images"]').fancybox({
        transitionEffect: "slide",

        // Support for retina displays.
        afterLoad : function(instance, current) {
            var pixelRatio = window.devicePixelRatio || 1;

            if ( pixelRatio > 1.5 ) {
                current.width  = current.width  / pixelRatio;
                current.height = current.height / pixelRatio;
            }
        }
    });
</script>


<script>
    // Show sidebar on top in mobile devices.
    $(".content").addClass("order-last order-md-first");
    $(".sidebar").addClass("order-first order-md-last");
</script>

</div>
<div class="sidebar col-md-3 mt-2 mt-md-0">
    
    <!-- https://github.com/christian-fei/Simple-Jekyll-Search -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/simple-jekyll-search/1.7.2/simple-jekyll-search.min.js" integrity="sha256-DsgE6Y6cI5eAZoTg8tJ5VBxFs+rnL8smPwt/u8tyAYo=" crossorigin="anonymous"></script>

<div id="search-box" class="mb-2">
    <input class="form-control" type="text" placeholder="Search" aria-label="Search">
    <ul class="mb-0"></ul>
</div>

<script type="text/javascript">
    var search_box = document.getElementById("search-box");
    SimpleJekyllSearch({
        searchInput: search_box.getElementsByTagName("input")[0],
        resultsContainer: search_box.getElementsByTagName("ul")[0],
        json: '/blog/assets/search.json',
        searchResultTemplate: '<li><a href="{url}">{title}</a></li>',
        noResultsText: 'No results found',
        fuzzy: false
    });
</script>

    <!-- https://github.com/tscanlin/tocbot/ -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.7.0/tocbot.css" integrity="sha256-XUbSD3m+xLW27W/mp9kMn+fI9AU2MoBkiMMSVVYWI+o=" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.7.0/tocbot.min.js" integrity="sha256-5K/04vUxP94HmQ8f18TgufdyqE69WDJRMNga0JLhAtE=" crossorigin="anonymous"></script>

<div class="toc-container mb-2">
    <p class="name">Table of Contents</p>
    <div class="toc py-2 pr-2 mb-2"></div>
</div>

<script>
    // Show TOC if the article contains any heading.
    if ($("article h1, article  h2, article h3, article h4, article h5, article h6").length == 0) {
        $(".toc-container").addClass("d-none");
    }

    tocbot.init({
        // Where to render the table of contents.
        tocSelector: ".toc",
        // Where to grab the headings to build the table of contents.
        contentSelector: "article",
        // Which headings to grab inside of the contentSelector element.
        headingSelector: "h1, h2, h3, h4, h5, h6",
        collapseDepth: 6,
    });
</script>






</div>


    </div>
</div>

        <footer>
    <div class="container">
        <hr class="my-0">
        <div class="row align-items-center text-muted my-3">
            <div class="col">
                <span>© 2023 Akash Sharma</span>
                <a href="/blog/feed.xml"><span class="feed iconify" data-icon="foundation:rss"></span></a>
            </div>
            <div class="col-auto text-center px-0">
                    <a href="https://akash-sharma-1.github.io/"><span class="github text-center text-muted iconify" data-icon="foundation:web"></span></a>
                    <a href="https://github.com/Akash-Sharma-1"><span class="github text-center text-muted iconify" data-icon="foundation:social-github"></span></a>
                    <a href="https://twitter.com/AkashTheGreat_1"><span class="github text-center text-muted iconify" data-icon="foundation:social-twitter"></span></a>
                    <a href="https://www.linkedin.com/in/akash-sharma-246b67165"><span class="github text-center text-muted iconify" data-icon="foundation:social-linkedin"></span></a>
                    <a href="mailto:akashthegreatlegend@gmail.com"><span class="github text-center text-muted iconify" data-icon="foundation:mail"></span></a>
            </div>
            <div class="col text-right">
                <a href="javascript:$('html,body').animate({ scrollTop: 0 }, 'slow');">TOP</a>
            </div>

        </div>
    </div>
</footer>

    </body>
</html>
